package generator

import (
	"fmt"
	"io/ioutil"
	"strings"
	"time"

	"github.com/suifei/xsd2code/pkg/types"
)

// CodeGenerator generates Go code from parsed XSD types
type CodeGenerator struct {
	packageName     string
	outputPath      string
	goTypes         []types.GoType
	jsonCompatible  bool
	includeComments bool
	debugMode       bool
}

// NewCodeGenerator creates a new code generator
func NewCodeGenerator(packageName, outputPath string) *CodeGenerator {
	return &CodeGenerator{
		packageName:     packageName,
		outputPath:      outputPath,
		goTypes:         make([]types.GoType, 0),
		jsonCompatible:  false,
		includeComments: true,
		debugMode:       false,
	}
}

// SetGoTypes sets the Go types to generate
func (g *CodeGenerator) SetGoTypes(goTypes []types.GoType) {
	g.goTypes = goTypes
}

// SetJSONCompatible enables or disables JSON compatibility
func (g *CodeGenerator) SetJSONCompatible(json bool) {
	g.jsonCompatible = json
}

// SetIncludeComments enables or disables comments
func (g *CodeGenerator) SetIncludeComments(comments bool) {
	g.includeComments = comments
}

// SetDebugMode enables or disables debug mode
func (g *CodeGenerator) SetDebugMode(debug bool) {
	g.debugMode = debug
}

// Generate generates the Go code and writes it to the output file
func (g *CodeGenerator) Generate() error {
	if g.debugMode {
		fmt.Printf("Generating Go code for %d types\n", len(g.goTypes))
	}

	code := g.generateCode()

	if err := ioutil.WriteFile(g.outputPath, []byte(code), 0644); err != nil {
		return fmt.Errorf("failed to write output file: %v", err)
	}

	if g.debugMode {
		fmt.Printf("Generated code written to: %s\n", g.outputPath)
	}

	return nil
}

// generateCode generates the complete Go code
func (g *CodeGenerator) generateCode() string {
	var builder strings.Builder

	// Package declaration and imports
	g.writeHeader(&builder)

	// Generate types
	for _, goType := range g.goTypes {
		g.writeType(&builder, goType)
		builder.WriteString("\n")
	}

	return builder.String()
}

// writeHeader writes the package declaration and imports
func (g *CodeGenerator) writeHeader(builder *strings.Builder) {
	builder.WriteString(fmt.Sprintf("// Code generated by xsd2code v3.0; DO NOT EDIT.\n"))
	builder.WriteString(fmt.Sprintf("// Generated on %s\n\n", time.Now().Format("2006-01-02 15:04:05")))

	builder.WriteString(fmt.Sprintf("package %s\n\n", g.packageName))

	// Imports
	builder.WriteString("import (\n")
	builder.WriteString("\t\"encoding/xml\"\n")

	if g.jsonCompatible {
		builder.WriteString("\t\"encoding/json\"\n")
	}

	// Check if we need time package
	needsTime := g.needsTimePackage()
	if needsTime {
		builder.WriteString("\t\"time\"\n")
	}

	builder.WriteString(")\n\n")
}

// needsTimePackage checks if the generated code needs the time package
func (g *CodeGenerator) needsTimePackage() bool {
	for _, goType := range g.goTypes {
		for _, field := range goType.Fields {
			if strings.Contains(field.Type, "time.Time") {
				return true
			}
		}
	}
	return false
}

// writeType writes a single Go type
func (g *CodeGenerator) writeType(builder *strings.Builder, goType types.GoType) {
	if goType.IsEnum {
		g.writeEnumType(builder, goType)
	} else {
		g.writeStructType(builder, goType)
	}
}

// writeStructType writes a struct type
func (g *CodeGenerator) writeStructType(builder *strings.Builder, goType types.GoType) {
	// Write comment
	if g.includeComments && goType.Comment != "" {
		g.writeComment(builder, fmt.Sprintf("%s %s", goType.Name, goType.Comment), "")
	} else if g.includeComments {
		g.writeComment(builder, fmt.Sprintf("%s represents %s", goType.Name, goType.XMLName), "")
	}

	// Write type declaration
	builder.WriteString(fmt.Sprintf("type %s struct {\n", goType.Name))

	// Write XMLName field if we have a namespace
	if goType.XMLName != "" {
		xmlNameTag := g.buildXMLNameTag(goType)
		jsonNameTag := ""
		if g.jsonCompatible {
			jsonNameTag = " json:\"-\""
		}
		builder.WriteString(fmt.Sprintf("\tXMLName xml.Name `xml:\"%s\"%s`\n", xmlNameTag, jsonNameTag))
	}

	// Write fields
	for _, field := range goType.Fields {
		g.writeField(builder, field)
	}

	builder.WriteString("}\n")
}

// writeEnumType writes an enum type with constants
func (g *CodeGenerator) writeEnumType(builder *strings.Builder, goType types.GoType) {
	// Write comment
	if g.includeComments && goType.Comment != "" {
		g.writeComment(builder, fmt.Sprintf("%s %s", goType.Name, goType.Comment), "")
	} else if g.includeComments {
		g.writeComment(builder, fmt.Sprintf("%s represents %s", goType.Name, goType.XMLName), "")
	}

	// Write type declaration
	baseType := goType.BaseType
	if baseType == "" {
		baseType = "string"
	}
	builder.WriteString(fmt.Sprintf("type %s %s\n\n", goType.Name, baseType))

	// Write constants
	if len(goType.Constants) > 0 {
		if g.includeComments {
			g.writeComment(builder, fmt.Sprintf("%s enumeration values", goType.Name), "")
		}
		builder.WriteString("const (\n")

		for _, constant := range goType.Constants {
			if g.includeComments && constant.Comment != "" {
				g.writeComment(builder, constant.Comment, "\t")
			}
			builder.WriteString(fmt.Sprintf("\t%s %s = %s\n", constant.Name, goType.Name, constant.Value))
		}

		builder.WriteString(")\n")
	}
}

// writeField writes a struct field
func (g *CodeGenerator) writeField(builder *strings.Builder, field types.GoField) {
	// Write comment
	if g.includeComments && field.Comment != "" {
		g.writeComment(builder, field.Comment, "\t")
	}

	// Build tags
	tags := g.buildFieldTags(field)

	// Write field
	builder.WriteString(fmt.Sprintf("\t%s %s %s\n", field.Name, field.Type, tags))
}

// buildXMLNameTag builds the XMLName tag
func (g *CodeGenerator) buildXMLNameTag(goType types.GoType) string {
	if goType.Namespace != "" {
		return fmt.Sprintf("%s %s", goType.Namespace, goType.XMLName)
	}
	return goType.XMLName
}

// buildFieldTags builds the struct tags for a field
func (g *CodeGenerator) buildFieldTags(field types.GoField) string {
	var tagParts []string

	// XML tag
	if field.XMLTag != "" {
		tagParts = append(tagParts, fmt.Sprintf("xml:\"%s\"", field.XMLTag))
	}

	// JSON tag
	if g.jsonCompatible && field.JSONTag != "" {
		tagParts = append(tagParts, fmt.Sprintf("json:\"%s\"", field.JSONTag))
	}

	if len(tagParts) == 0 {
		return ""
	}

	return "`" + strings.Join(tagParts, " ") + "`"
}

// writeComment writes a comment with proper formatting
func (g *CodeGenerator) writeComment(builder *strings.Builder, comment, indent string) {
	if comment == "" {
		return
	}

	// Clean up the comment
	comment = strings.TrimSpace(comment)
	comment = strings.ReplaceAll(comment, "\n", " ")
	comment = strings.ReplaceAll(comment, "\r", " ")

	// Handle multi-line comments
	words := strings.Fields(comment)
	const maxLineLength = 80

	currentLine := indent + "// "
	for i, word := range words {
		if len(currentLine)+len(word)+1 > maxLineLength && i > 0 {
			builder.WriteString(currentLine + "\n")
			currentLine = indent + "// " + word
		} else {
			if currentLine == indent+"// " {
				currentLine += word
			} else {
				currentLine += " " + word
			}
		}
	}

	if currentLine != indent+"// " {
		builder.WriteString(currentLine + "\n")
	}
}

// GenerateValidationCode generates validation functions for XSD types
func (g *CodeGenerator) GenerateValidationCode() string {
	var builder strings.Builder

	builder.WriteString("// Generated validation functions\n\n")
	builder.WriteString("import (\n")
	builder.WriteString("\t\"fmt\"\n")
	builder.WriteString("\t\"regexp\"\n")
	builder.WriteString("\t\"strconv\"\n")
	builder.WriteString("\t\"time\"\n")
	builder.WriteString(")\n\n")

	// Generate validation interface
	builder.WriteString("// Validator interface for all generated types\n")
	builder.WriteString("type Validator interface {\n")
	builder.WriteString("\tValidate() error\n")
	builder.WriteString("}\n\n")
	// Generate validation functions for each type
	for _, goType := range g.goTypes {
		g.generateTypeValidator(&builder, &goType)
	}

	// Generate helper validation functions
	g.generateValidationHelpers(&builder)

	return builder.String()
}

// generateTypeValidator generates validation method for a specific type
func (g *CodeGenerator) generateTypeValidator(builder *strings.Builder, goType *types.GoType) {
	typeName := goType.Name

	builder.WriteString(fmt.Sprintf("// Validate validates the %s struct\n", typeName))
	builder.WriteString(fmt.Sprintf("func (v *%s) Validate() error {\n", typeName))

	// Generate field validations
	for _, field := range goType.Fields {
		g.generateFieldValidation(builder, &field, typeName)
	}

	builder.WriteString("\treturn nil\n")
	builder.WriteString("}\n\n")
}

// generateFieldValidation generates validation code for a field
func (g *CodeGenerator) generateFieldValidation(builder *strings.Builder, field *types.GoField, typeName string) {
	fieldName := field.Name

	// Required field validation
	if !field.IsOptional && !field.IsArray {
		if strings.HasPrefix(field.Type, "*") {
			builder.WriteString(fmt.Sprintf("\tif v.%s == nil {\n", fieldName))
			builder.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"%s.%s is required\")\n", typeName, fieldName))
			builder.WriteString("\t}\n")
		} else if field.Type == "string" {
			builder.WriteString(fmt.Sprintf("\tif v.%s == \"\" {\n", fieldName))
			builder.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"%s.%s is required\")\n", typeName, fieldName))
			builder.WriteString("\t}\n")
		}
	}

	// Array length validation
	if field.IsArray && field.MinOccurs > 0 {
		builder.WriteString(fmt.Sprintf("\tif len(v.%s) < %d {\n", fieldName, field.MinOccurs))
		builder.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"%s.%s must have at least %d elements\")\n",
			typeName, fieldName, field.MinOccurs))
		builder.WriteString("\t}\n")
	}

	if field.IsArray && field.MaxOccurs > 0 && field.MaxOccurs != -1 {
		builder.WriteString(fmt.Sprintf("\tif len(v.%s) > %d {\n", fieldName, field.MaxOccurs))
		builder.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"%s.%s must have at most %d elements\")\n",
			typeName, fieldName, field.MaxOccurs))
		builder.WriteString("\t}\n")
	}

	// Type-specific validation
	g.generateTypeSpecificValidation(builder, field, typeName)
}

// generateTypeSpecificValidation generates type-specific validation code
func (g *CodeGenerator) generateTypeSpecificValidation(builder *strings.Builder, field *types.GoField, typeName string) {
	fieldName := field.Name
	baseType := strings.TrimPrefix(field.Type, "*")
	baseType = strings.TrimPrefix(baseType, "[]")

	switch baseType {
	case "time.Time":
		if field.IsOptional {
			builder.WriteString(fmt.Sprintf("\tif v.%s != nil {\n", fieldName))
			builder.WriteString(fmt.Sprintf("\t\tif err := validateDateTime(*v.%s); err != nil {\n", fieldName))
			builder.WriteString(fmt.Sprintf("\t\t\treturn fmt.Errorf(\"%s.%s: %%v\", err)\n", typeName, fieldName))
			builder.WriteString("\t\t}\n")
			builder.WriteString("\t}\n")
		} else if field.IsArray {
			builder.WriteString(fmt.Sprintf("\tfor i, dt := range v.%s {\n", fieldName))
			builder.WriteString("\t\tif err := validateDateTime(dt); err != nil {\n")
			builder.WriteString(fmt.Sprintf("\t\t\treturn fmt.Errorf(\"%s.%s[%%d]: %%v\", i, err)\n", typeName, fieldName))
			builder.WriteString("\t\t}\n")
			builder.WriteString("\t}\n")
		} else {
			builder.WriteString(fmt.Sprintf("\tif err := validateDateTime(v.%s); err != nil {\n", fieldName))
			builder.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"%s.%s: %%v\", err)\n", typeName, fieldName))
			builder.WriteString("\t}\n")
		}
	}
}

// generateValidationHelpers generates helper validation functions
func (g *CodeGenerator) generateValidationHelpers(builder *strings.Builder) {
	builder.WriteString("// Helper validation functions\n\n")

	// DateTime validation
	builder.WriteString("func validateDateTime(dt time.Time) error {\n")
	builder.WriteString("\tif dt.IsZero() {\n")
	builder.WriteString("\t\treturn fmt.Errorf(\"invalid datetime\")\n")
	builder.WriteString("\t}\n")
	builder.WriteString("\treturn nil\n")
	builder.WriteString("}\n\n")

	// String pattern validation
	builder.WriteString("func validatePattern(value, pattern string) error {\n")
	builder.WriteString("\tmatched, err := regexp.MatchString(pattern, value)\n")
	builder.WriteString("\tif err != nil {\n")
	builder.WriteString("\t\treturn fmt.Errorf(\"invalid pattern: %v\", err)\n")
	builder.WriteString("\t}\n")
	builder.WriteString("\tif !matched {\n")
	builder.WriteString("\t\treturn fmt.Errorf(\"value does not match pattern %s\", pattern)\n")
	builder.WriteString("\t}\n")
	builder.WriteString("\treturn nil\n")
	builder.WriteString("}\n\n")

	// Number range validation
	builder.WriteString("func validateIntRange(value, min, max int) error {\n")
	builder.WriteString("\tif value < min || value > max {\n")
	builder.WriteString("\t\treturn fmt.Errorf(\"value %d is out of range [%d, %d]\", value, min, max)\n")
	builder.WriteString("\t}\n")
	builder.WriteString("\treturn nil\n")
	builder.WriteString("}\n")
}

// GenerateTestCode generates test code for the generated types
func (g *CodeGenerator) GenerateTestCode() string {
	var builder strings.Builder

	builder.WriteString("// Generated test code\n\n")
	builder.WriteString("import (\n")
	builder.WriteString("\t\"encoding/xml\"\n")
	builder.WriteString("\t\"testing\"\n")
	builder.WriteString("\t\"time\"\n")
	builder.WriteString(")\n\n")
	// Generate test functions for each type
	for _, goType := range g.goTypes {
		g.generateTypeTest(&builder, &goType)
	}

	// Generate benchmark tests
	g.generateBenchmarkTests(&builder)

	return builder.String()
}

// generateTypeTest generates test function for a specific type
func (g *CodeGenerator) generateTypeTest(builder *strings.Builder, goType *types.GoType) {
	typeName := goType.Name

	// Test XML marshaling/unmarshaling
	builder.WriteString(fmt.Sprintf("func Test%sXMLMarshaling(t *testing.T) {\n", typeName))
	builder.WriteString(fmt.Sprintf("\toriginal := &%s{\n", typeName))

	// Generate test data for fields
	for _, field := range goType.Fields {
		g.generateTestFieldData(builder, &field)
	}

	builder.WriteString("\t}\n\n")

	// Test marshaling
	builder.WriteString("\t// Test marshaling\n")
	builder.WriteString("\txmlData, err := xml.Marshal(original)\n")
	builder.WriteString("\tif err != nil {\n")
	builder.WriteString("\t\tt.Fatalf(\"Failed to marshal XML: %v\", err)\n")
	builder.WriteString("\t}\n\n")

	// Test unmarshaling
	builder.WriteString("\t// Test unmarshaling\n")
	builder.WriteString(fmt.Sprintf("\tvar unmarshaled %s\n", typeName))
	builder.WriteString("\terr = xml.Unmarshal(xmlData, &unmarshaled)\n")
	builder.WriteString("\tif err != nil {\n")
	builder.WriteString("\t\tt.Fatalf(\"Failed to unmarshal XML: %v\", err)\n")
	builder.WriteString("\t}\n\n")

	// Test validation if implemented
	builder.WriteString("\t// Test validation\n")
	builder.WriteString("\tif err := original.Validate(); err != nil {\n")
	builder.WriteString("\t\tt.Errorf(\"Validation failed: %v\", err)\n")
	builder.WriteString("\t}\n")

	builder.WriteString("}\n\n")

	// Generate validation test
	g.generateValidationTest(builder, goType)
}

// generateTestFieldData generates test data for a field
func (g *CodeGenerator) generateTestFieldData(builder *strings.Builder, field *types.GoField) {
	fieldName := field.Name
	baseType := strings.TrimPrefix(field.Type, "*")
	baseType = strings.TrimPrefix(baseType, "[]")

	if field.IsArray {
		builder.WriteString(fmt.Sprintf("\t\t%s: []%s{", fieldName, baseType))
		g.generateSampleValue(builder, baseType)
		builder.WriteString("},\n")
	} else if field.IsOptional && strings.HasPrefix(field.Type, "*") {
		builder.WriteString(fmt.Sprintf("\t\t%s: ", fieldName))
		g.generatePointerValue(builder, baseType)
		builder.WriteString(",\n")
	} else {
		builder.WriteString(fmt.Sprintf("\t\t%s: ", fieldName))
		g.generateSampleValue(builder, baseType)
		builder.WriteString(",\n")
	}
}

// generateSampleValue generates a sample value for a type
func (g *CodeGenerator) generateSampleValue(builder *strings.Builder, typeName string) {
	switch typeName {
	case "string":
		builder.WriteString("\"test_value\"")
	case "int", "int32", "int64":
		builder.WriteString("42")
	case "float32", "float64":
		builder.WriteString("3.14")
	case "bool":
		builder.WriteString("true")
	case "time.Time":
		builder.WriteString("time.Now()")
	default:
		// Assume it's a custom type
		builder.WriteString(fmt.Sprintf("%s{}", typeName))
	}
}

// generatePointerValue generates a pointer value for a type
func (g *CodeGenerator) generatePointerValue(builder *strings.Builder, typeName string) {
	switch typeName {
	case "string":
		builder.WriteString("stringPtr(\"test_value\")")
	case "int", "int32", "int64":
		builder.WriteString("intPtr(42)")
	case "float32", "float64":
		builder.WriteString("floatPtr(3.14)")
	case "bool":
		builder.WriteString("boolPtr(true)")
	case "time.Time":
		builder.WriteString("timePtr(time.Now())")
	default:
		// Assume it's a custom type
		builder.WriteString(fmt.Sprintf("&%s{}", typeName))
	}
}

// generateValidationTest generates validation test cases
func (g *CodeGenerator) generateValidationTest(builder *strings.Builder, goType *types.GoType) {
	typeName := goType.Name

	builder.WriteString(fmt.Sprintf("func Test%sValidation(t *testing.T) {\n", typeName))

	// Test valid case
	builder.WriteString("\t// Test valid case\n")
	builder.WriteString(fmt.Sprintf("\tvalid := &%s{\n", typeName))
	for _, field := range goType.Fields {
		if !field.IsOptional {
			g.generateTestFieldData(builder, &field)
		}
	}
	builder.WriteString("\t}\n")
	builder.WriteString("\tif err := valid.Validate(); err != nil {\n")
	builder.WriteString("\t\tt.Errorf(\"Valid object should not have validation errors: %v\", err)\n")
	builder.WriteString("\t}\n\n")

	// Test invalid cases for required fields
	for _, field := range goType.Fields {
		if !field.IsOptional {
			g.generateInvalidFieldTest(builder, &field, typeName)
		}
	}

	builder.WriteString("}\n\n")
}

// generateInvalidFieldTest generates test for invalid field values
func (g *CodeGenerator) generateInvalidFieldTest(builder *strings.Builder, field *types.GoField, typeName string) {
	fieldName := field.Name

	builder.WriteString(fmt.Sprintf("\t// Test missing required field: %s\n", fieldName))
	builder.WriteString(fmt.Sprintf("\tinvalid%s := &%s{}\n", fieldName, typeName))
	builder.WriteString(fmt.Sprintf("\tif err := invalid%s.Validate(); err == nil {\n", fieldName))
	builder.WriteString(fmt.Sprintf("\t\tt.Error(\"Missing required field %s should cause validation error\")\n", fieldName))
	builder.WriteString("\t}\n\n")
}

// generateBenchmarkTests generates benchmark tests
func (g *CodeGenerator) generateBenchmarkTests(builder *strings.Builder) {
	builder.WriteString("// Benchmark tests\n\n")
	for _, goType := range g.goTypes {
		typeName := goType.Name

		builder.WriteString(fmt.Sprintf("func Benchmark%sMarshaling(b *testing.B) {\n", typeName))
		builder.WriteString(fmt.Sprintf("\tobj := &%s{\n", typeName))

		// Generate sample data
		for _, field := range goType.Fields {
			if !field.IsOptional {
				g.generateTestFieldData(builder, &field)
			}
		}

		builder.WriteString("\t}\n\n")

		builder.WriteString("\tb.ResetTimer()\n")
		builder.WriteString("\tfor i := 0; i < b.N; i++ {\n")
		builder.WriteString("\t\t_, err := xml.Marshal(obj)\n")
		builder.WriteString("\t\tif err != nil {\n")
		builder.WriteString("\t\t\tb.Fatal(err)\n")
		builder.WriteString("\t\t}\n")
		builder.WriteString("\t}\n")
		builder.WriteString("}\n\n")
	}

	// Helper functions for pointer creation
	builder.WriteString("// Helper functions for creating pointers\n\n")
	builder.WriteString("func stringPtr(s string) *string { return &s }\n")
	builder.WriteString("func intPtr(i int) *int { return &i }\n")
	builder.WriteString("func floatPtr(f float64) *float64 { return &f }\n")
	builder.WriteString("func boolPtr(b bool) *bool { return &b }\n")
	builder.WriteString("func timePtr(t time.Time) *time.Time { return &t }\n")
}
