// Code generated by xsd2code v3.0; DO NOT EDIT.
// Generated on 2025-06-01 00:32:44

package models

import (
	"encoding/xml"
	"time"
)

// DataTypeString DataTypeString represents the inline complex type for element
// string
type DataTypeString struct {
	XMLName xml.Name `xml:"string"`
	Length *uint64 `xml:"length,attr"`
}

// DataTypeWstring DataTypeWstring represents the inline complex type for
// element wstring
type DataTypeWstring struct {
	XMLName xml.Name `xml:"wstring"`
	Length *uint64 `xml:"length,attr"`
}

// DataTypeArray DataTypeArray represents the inline complex type for element
// array
type DataTypeArray struct {
	XMLName xml.Name `xml:"array"`
	Dimension []RangeSigned `xml:"dimension"`
	BaseType DataType `xml:"baseType"`
}

// DataTypeDerived DataTypeDerived represents the inline complex type for
// element derived
type DataTypeDerived struct {
	XMLName xml.Name `xml:"derived"`
	Name string `xml:"name,attr"`
}

// DataTypeEnumValuesValue DataTypeEnumValuesValue represents the inline complex
// type for element value
type DataTypeEnumValuesValue struct {
	XMLName xml.Name `xml:"value"`
	Name string `xml:"name,attr"`
	Value *string `xml:"value,attr"`
}

// DataTypeEnumValues DataTypeEnumValues represents the inline complex type for
// element values
type DataTypeEnumValues struct {
	XMLName xml.Name `xml:"values"`
	Value DataTypeEnumValuesValue `xml:"value"`
}

// DataTypeEnum DataTypeEnum represents the inline complex type for element enum
type DataTypeEnum struct {
	XMLName xml.Name `xml:"enum"`
	Values DataTypeEnumValues `xml:"values"`
	BaseType *DataType `xml:"baseType,omitempty"`
}

// DataTypeSubrangeSigned DataTypeSubrangeSigned represents the inline complex
// type for element subrangeSigned
type DataTypeSubrangeSigned struct {
	XMLName xml.Name `xml:"subrangeSigned"`
	Range RangeSigned `xml:"range"`
	BaseType DataType `xml:"baseType"`
}

// DataTypeSubrangeUnsigned DataTypeSubrangeUnsigned represents the inline
// complex type for element subrangeUnsigned
type DataTypeSubrangeUnsigned struct {
	XMLName xml.Name `xml:"subrangeUnsigned"`
	Range RangeUnsigned `xml:"range"`
	BaseType DataType `xml:"baseType"`
}

// DataTypePointer DataTypePointer represents the inline complex type for
// element pointer
type DataTypePointer struct {
	XMLName xml.Name `xml:"pointer"`
	BaseType DataType `xml:"baseType"`
}

// DataType A generic data type
type DataType struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd dataType"`
	BOOL bool `xml:"BOOL,omitempty"`
	BYTE uint8 `xml:"BYTE,omitempty"`
	WORD uint16 `xml:"WORD,omitempty"`
	DWORD uint32 `xml:"DWORD,omitempty"`
	LWORD uint64 `xml:"LWORD,omitempty"`
	SINT int8 `xml:"SINT,omitempty"`
	INT int16 `xml:"INT,omitempty"`
	DINT int32 `xml:"DINT,omitempty"`
	LINT int64 `xml:"LINT,omitempty"`
	USINT uint8 `xml:"USINT,omitempty"`
	UINT uint16 `xml:"UINT,omitempty"`
	UDINT uint32 `xml:"UDINT,omitempty"`
	ULINT uint64 `xml:"ULINT,omitempty"`
	REAL float32 `xml:"REAL,omitempty"`
	LREAL float64 `xml:"LREAL,omitempty"`
	TIME *time.Duration `xml:"TIME,omitempty"`
	DATE *time.Time `xml:"DATE,omitempty"`
	DT *time.Time `xml:"DT,omitempty"`
	TOD *time.Time `xml:"TOD,omitempty"`
	String *DataTypeString `xml:"string,omitempty"`
	Wstring *DataTypeWstring `xml:"wstring,omitempty"`
	Array *DataTypeArray `xml:"array,omitempty"`
	// Reference to a user defined datatype or POU. Variable declarations use this
	// type to declare e.g. function block instances.
	Derived *DataTypeDerived `xml:"derived,omitempty"`
	Enum *DataTypeEnum `xml:"enum,omitempty"`
	Struct *VarListPlain `xml:"struct,omitempty"`
	SubrangeSigned *DataTypeSubrangeSigned `xml:"subrangeSigned,omitempty"`
	SubrangeUnsigned *DataTypeSubrangeUnsigned `xml:"subrangeUnsigned,omitempty"`
	Pointer *DataTypePointer `xml:"pointer,omitempty"`
}

// RangeSigned Defines a range with signed bounds
type RangeSigned struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd rangeSigned"`
	Lower int64 `xml:"lower,attr"`
	Upper int64 `xml:"upper,attr"`
}

// RangeUnsigned Defines a range with unsigned bounds
type RangeUnsigned struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd rangeUnsigned"`
	Lower uint64 `xml:"lower,attr"`
	Upper uint64 `xml:"upper,attr"`
}

// ValueSimpleValue ValueSimpleValue represents the inline complex type for
// element simpleValue
type ValueSimpleValue struct {
	XMLName xml.Name `xml:"simpleValue"`
	Value *string `xml:"value,attr"`
}

// ValueArrayValueValue ValueArrayValueValue represents the inline complex type
// for element value
type ValueArrayValueValue struct {
	XMLName xml.Name `xml:"value"`
}

// ValueArrayValue ValueArrayValue represents the inline complex type for
// element arrayValue
type ValueArrayValue struct {
	XMLName xml.Name `xml:"arrayValue"`
	Value ValueArrayValueValue `xml:"value"`
}

// ValueStructValueValue ValueStructValueValue represents the inline complex
// type for element value
type ValueStructValueValue struct {
	XMLName xml.Name `xml:"value"`
}

// ValueStructValue ValueStructValue represents the inline complex type for
// element structValue
type ValueStructValue struct {
	XMLName xml.Name `xml:"structValue"`
	Value ValueStructValueValue `xml:"value"`
}

// Value A generic value
type Value struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd value"`
	SimpleValue *ValueSimpleValue `xml:"simpleValue,omitempty"`
	ArrayValue *ValueArrayValue `xml:"arrayValue,omitempty"`
	StructValue *ValueStructValue `xml:"structValue,omitempty"`
}

// BodyFBDComment BodyFBDComment represents the inline complex type for element
// comment
type BodyFBDComment struct {
	XMLName xml.Name `xml:"comment"`
	Position Position `xml:"position"`
	Content FormattedText `xml:"content"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height float64 `xml:"height,attr"`
	Width float64 `xml:"width,attr"`
}

// BodyFBDError BodyFBDError represents the inline complex type for element
// error
type BodyFBDError struct {
	XMLName xml.Name `xml:"error"`
	Position Position `xml:"position"`
	Content FormattedText `xml:"content"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height float64 `xml:"height,attr"`
	Width float64 `xml:"width,attr"`
}

// BodyFBDConnector BodyFBDConnector represents the inline complex type for
// element connector
type BodyFBDConnector struct {
	XMLName xml.Name `xml:"connector"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	// The operand is a valid iec variable e.g. avar[0]
	Name string `xml:"name,attr"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodyFBDContinuation BodyFBDContinuation represents the inline complex type
// for element continuation
type BodyFBDContinuation struct {
	XMLName xml.Name `xml:"continuation"`
	Position Position `xml:"position"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	// The operand is a valid iec variable e.g. avar[0]
	Name string `xml:"name,attr"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodyFBDActionBlockActionReference BodyFBDActionBlockActionReference
// represents the inline complex type for element reference
type BodyFBDActionBlockActionReference struct {
	XMLName xml.Name `xml:"reference"`
	Name string `xml:"name,attr"`
}

// BodyFBDActionBlockAction BodyFBDActionBlockAction represents the inline
// complex type for element action
type BodyFBDActionBlockAction struct {
	XMLName xml.Name `xml:"action"`
	// Name of an action or boolean variable.
	Reference *BodyFBDActionBlockActionReference `xml:"reference,omitempty"`
	// Inline implementation of an action body.
	Inline *Body `xml:"inline,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	Qualifier *string `xml:"qualifier,attr"`
	Duration *string `xml:"duration,attr"`
	Indicator *string `xml:"indicator,attr"`
}

// BodyFBDActionBlock BodyFBDActionBlock represents the inline complex type for
// element actionBlock
type BodyFBDActionBlock struct {
	XMLName xml.Name `xml:"actionBlock"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Action []BodyFBDActionBlockAction `xml:"action,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	Negated *bool `xml:"negated,attr"`
}

// BodyFBDBlockInputVariablesVariable BodyFBDBlockInputVariablesVariable
// represents the inline complex type for element variable
type BodyFBDBlockInputVariablesVariable struct {
	XMLName xml.Name `xml:"variable"`
	ConnectionPointIn ConnectionPointIn `xml:"connectionPointIn"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	FormalParameter string `xml:"formalParameter,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
	Hidden *bool `xml:"hidden,attr"`
}

// BodyFBDBlockInputVariables BodyFBDBlockInputVariables represents the inline
// complex type for element inputVariables
type BodyFBDBlockInputVariables struct {
	XMLName xml.Name `xml:"inputVariables"`
	Variable []BodyFBDBlockInputVariablesVariable `xml:"variable,omitempty"`
}

// BodyFBDBlockInOutVariablesVariable BodyFBDBlockInOutVariablesVariable
// represents the inline complex type for element variable
type BodyFBDBlockInOutVariablesVariable struct {
	XMLName xml.Name `xml:"variable"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	FormalParameter string `xml:"formalParameter,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
	Hidden *bool `xml:"hidden,attr"`
}

// BodyFBDBlockInOutVariables BodyFBDBlockInOutVariables represents the inline
// complex type for element inOutVariables
type BodyFBDBlockInOutVariables struct {
	XMLName xml.Name `xml:"inOutVariables"`
	Variable []BodyFBDBlockInOutVariablesVariable `xml:"variable,omitempty"`
}

// BodyFBDBlockOutputVariablesVariable BodyFBDBlockOutputVariablesVariable
// represents the inline complex type for element variable
type BodyFBDBlockOutputVariablesVariable struct {
	XMLName xml.Name `xml:"variable"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	FormalParameter string `xml:"formalParameter,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
	Hidden *bool `xml:"hidden,attr"`
}

// BodyFBDBlockOutputVariables BodyFBDBlockOutputVariables represents the inline
// complex type for element outputVariables
type BodyFBDBlockOutputVariables struct {
	XMLName xml.Name `xml:"outputVariables"`
	Variable []BodyFBDBlockOutputVariablesVariable `xml:"variable,omitempty"`
}

// BodyFBDBlock BodyFBDBlock represents the inline complex type for element
// block
type BodyFBDBlock struct {
	XMLName xml.Name `xml:"block"`
	// Anchor position of the box. Top left corner excluding the instance name.
	Position Position `xml:"position"`
	// The list of used input variables (consumers)
	InputVariables BodyFBDBlockInputVariables `xml:"inputVariables"`
	// The list of used inOut variables
	InOutVariables BodyFBDBlockInOutVariables `xml:"inOutVariables"`
	// The list of used output variables (producers)
	OutputVariables BodyFBDBlockOutputVariables `xml:"outputVariables"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Width *float64 `xml:"width,attr"`
	Height *float64 `xml:"height,attr"`
	TypeName string `xml:"typeName,attr"`
	InstanceName *string `xml:"instanceName,attr"`
	// Used to identify the order of execution. Also used to identify one special
	// block if there are several blocks with the same name.
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
}

// BodyFBDInVariable BodyFBDInVariable represents the inline complex type for
// element inVariable
type BodyFBDInVariable struct {
	XMLName xml.Name `xml:"inVariable"`
	Position Position `xml:"position"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	// The operand is a valid iec variable e.g. avar[0].
	Expression string `xml:"expression"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
}

// BodyFBDOutVariable BodyFBDOutVariable represents the inline complex type for
// element outVariable
type BodyFBDOutVariable struct {
	XMLName xml.Name `xml:"outVariable"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	// The operand is a valid iec variable e.g. avar[0].
	Expression string `xml:"expression"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
}

// BodyFBDInOutVariable BodyFBDInOutVariable represents the inline complex type
// for element inOutVariable
type BodyFBDInOutVariable struct {
	XMLName xml.Name `xml:"inOutVariable"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	// The operand is a valid iec variable e.g. avar[0].
	Expression string `xml:"expression"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	NegatedIn *bool `xml:"negatedIn,attr"`
	EdgeIn *EdgeModifierType `xml:"edgeIn,attr"`
	StorageIn *StorageModifierType `xml:"storageIn,attr"`
	NegatedOut *bool `xml:"negatedOut,attr"`
	EdgeOut *EdgeModifierType `xml:"edgeOut,attr"`
	StorageOut *StorageModifierType `xml:"storageOut,attr"`
}

// BodyFBDLabel BodyFBDLabel represents the inline complex type for element
// label
type BodyFBDLabel struct {
	XMLName xml.Name `xml:"label"`
	Position Position `xml:"position"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	Label string `xml:"label,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
}

// BodyFBDJump BodyFBDJump represents the inline complex type for element jump
type BodyFBDJump struct {
	XMLName xml.Name `xml:"jump"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	Label string `xml:"label,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
}

// BodyFBDReturn BodyFBDReturn represents the inline complex type for element
// return
type BodyFBDReturn struct {
	XMLName xml.Name `xml:"return"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
}

// BodyFBD BodyFBD represents the inline complex type for element FBD
type BodyFBD struct {
	XMLName xml.Name `xml:"FBD"`
	Comment *BodyFBDComment `xml:"comment,omitempty"`
	Error *BodyFBDError `xml:"error,omitempty"`
	Connector *BodyFBDConnector `xml:"connector,omitempty"`
	// Counterpart of the connector element
	Continuation *BodyFBDContinuation `xml:"continuation,omitempty"`
	ActionBlock *BodyFBDActionBlock `xml:"actionBlock,omitempty"`
	Block *BodyFBDBlock `xml:"block,omitempty"`
	// Expression used as producer
	InVariable *BodyFBDInVariable `xml:"inVariable,omitempty"`
	// Expression used as consumer
	OutVariable *BodyFBDOutVariable `xml:"outVariable,omitempty"`
	// Expression used as producer and consumer
	InOutVariable *BodyFBDInOutVariable `xml:"inOutVariable,omitempty"`
	Label *BodyFBDLabel `xml:"label,omitempty"`
	Jump *BodyFBDJump `xml:"jump,omitempty"`
	Return *BodyFBDReturn `xml:"return,omitempty"`
}

// BodyLDComment BodyLDComment represents the inline complex type for element
// comment
type BodyLDComment struct {
	XMLName xml.Name `xml:"comment"`
	Position Position `xml:"position"`
	Content FormattedText `xml:"content"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height float64 `xml:"height,attr"`
	Width float64 `xml:"width,attr"`
}

// BodyLDError BodyLDError represents the inline complex type for element error
type BodyLDError struct {
	XMLName xml.Name `xml:"error"`
	Position Position `xml:"position"`
	Content FormattedText `xml:"content"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height float64 `xml:"height,attr"`
	Width float64 `xml:"width,attr"`
}

// BodyLDConnector BodyLDConnector represents the inline complex type for
// element connector
type BodyLDConnector struct {
	XMLName xml.Name `xml:"connector"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	// The operand is a valid iec variable e.g. avar[0]
	Name string `xml:"name,attr"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodyLDContinuation BodyLDContinuation represents the inline complex type for
// element continuation
type BodyLDContinuation struct {
	XMLName xml.Name `xml:"continuation"`
	Position Position `xml:"position"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	// The operand is a valid iec variable e.g. avar[0]
	Name string `xml:"name,attr"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodyLDActionBlockActionReference BodyLDActionBlockActionReference represents
// the inline complex type for element reference
type BodyLDActionBlockActionReference struct {
	XMLName xml.Name `xml:"reference"`
	Name string `xml:"name,attr"`
}

// BodyLDActionBlockAction BodyLDActionBlockAction represents the inline complex
// type for element action
type BodyLDActionBlockAction struct {
	XMLName xml.Name `xml:"action"`
	// Name of an action or boolean variable.
	Reference *BodyLDActionBlockActionReference `xml:"reference,omitempty"`
	// Inline implementation of an action body.
	Inline *Body `xml:"inline,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	Qualifier *string `xml:"qualifier,attr"`
	Duration *string `xml:"duration,attr"`
	Indicator *string `xml:"indicator,attr"`
}

// BodyLDActionBlock BodyLDActionBlock represents the inline complex type for
// element actionBlock
type BodyLDActionBlock struct {
	XMLName xml.Name `xml:"actionBlock"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Action []BodyLDActionBlockAction `xml:"action,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	Negated *bool `xml:"negated,attr"`
}

// BodyLDBlockInputVariablesVariable BodyLDBlockInputVariablesVariable
// represents the inline complex type for element variable
type BodyLDBlockInputVariablesVariable struct {
	XMLName xml.Name `xml:"variable"`
	ConnectionPointIn ConnectionPointIn `xml:"connectionPointIn"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	FormalParameter string `xml:"formalParameter,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
	Hidden *bool `xml:"hidden,attr"`
}

// BodyLDBlockInputVariables BodyLDBlockInputVariables represents the inline
// complex type for element inputVariables
type BodyLDBlockInputVariables struct {
	XMLName xml.Name `xml:"inputVariables"`
	Variable []BodyLDBlockInputVariablesVariable `xml:"variable,omitempty"`
}

// BodyLDBlockInOutVariablesVariable BodyLDBlockInOutVariablesVariable
// represents the inline complex type for element variable
type BodyLDBlockInOutVariablesVariable struct {
	XMLName xml.Name `xml:"variable"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	FormalParameter string `xml:"formalParameter,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
	Hidden *bool `xml:"hidden,attr"`
}

// BodyLDBlockInOutVariables BodyLDBlockInOutVariables represents the inline
// complex type for element inOutVariables
type BodyLDBlockInOutVariables struct {
	XMLName xml.Name `xml:"inOutVariables"`
	Variable []BodyLDBlockInOutVariablesVariable `xml:"variable,omitempty"`
}

// BodyLDBlockOutputVariablesVariable BodyLDBlockOutputVariablesVariable
// represents the inline complex type for element variable
type BodyLDBlockOutputVariablesVariable struct {
	XMLName xml.Name `xml:"variable"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	FormalParameter string `xml:"formalParameter,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
	Hidden *bool `xml:"hidden,attr"`
}

// BodyLDBlockOutputVariables BodyLDBlockOutputVariables represents the inline
// complex type for element outputVariables
type BodyLDBlockOutputVariables struct {
	XMLName xml.Name `xml:"outputVariables"`
	Variable []BodyLDBlockOutputVariablesVariable `xml:"variable,omitempty"`
}

// BodyLDBlock BodyLDBlock represents the inline complex type for element block
type BodyLDBlock struct {
	XMLName xml.Name `xml:"block"`
	// Anchor position of the box. Top left corner excluding the instance name.
	Position Position `xml:"position"`
	// The list of used input variables (consumers)
	InputVariables BodyLDBlockInputVariables `xml:"inputVariables"`
	// The list of used inOut variables
	InOutVariables BodyLDBlockInOutVariables `xml:"inOutVariables"`
	// The list of used output variables (producers)
	OutputVariables BodyLDBlockOutputVariables `xml:"outputVariables"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Width *float64 `xml:"width,attr"`
	Height *float64 `xml:"height,attr"`
	TypeName string `xml:"typeName,attr"`
	InstanceName *string `xml:"instanceName,attr"`
	// Used to identify the order of execution. Also used to identify one special
	// block if there are several blocks with the same name.
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
}

// BodyLDInVariable BodyLDInVariable represents the inline complex type for
// element inVariable
type BodyLDInVariable struct {
	XMLName xml.Name `xml:"inVariable"`
	Position Position `xml:"position"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	// The operand is a valid iec variable e.g. avar[0].
	Expression string `xml:"expression"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
}

// BodyLDOutVariable BodyLDOutVariable represents the inline complex type for
// element outVariable
type BodyLDOutVariable struct {
	XMLName xml.Name `xml:"outVariable"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	// The operand is a valid iec variable e.g. avar[0].
	Expression string `xml:"expression"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
}

// BodyLDInOutVariable BodyLDInOutVariable represents the inline complex type
// for element inOutVariable
type BodyLDInOutVariable struct {
	XMLName xml.Name `xml:"inOutVariable"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	// The operand is a valid iec variable e.g. avar[0].
	Expression string `xml:"expression"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	NegatedIn *bool `xml:"negatedIn,attr"`
	EdgeIn *EdgeModifierType `xml:"edgeIn,attr"`
	StorageIn *StorageModifierType `xml:"storageIn,attr"`
	NegatedOut *bool `xml:"negatedOut,attr"`
	EdgeOut *EdgeModifierType `xml:"edgeOut,attr"`
	StorageOut *StorageModifierType `xml:"storageOut,attr"`
}

// BodyLDLabel BodyLDLabel represents the inline complex type for element label
type BodyLDLabel struct {
	XMLName xml.Name `xml:"label"`
	Position Position `xml:"position"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	Label string `xml:"label,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
}

// BodyLDJump BodyLDJump represents the inline complex type for element jump
type BodyLDJump struct {
	XMLName xml.Name `xml:"jump"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	Label string `xml:"label,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
}

// BodyLDReturn BodyLDReturn represents the inline complex type for element
// return
type BodyLDReturn struct {
	XMLName xml.Name `xml:"return"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
}

// BodyLDLeftPowerRailConnectionPointOut BodyLDLeftPowerRailConnectionPointOut
// represents the inline complex type for element connectionPointOut
type BodyLDLeftPowerRailConnectionPointOut struct {
	XMLName xml.Name `xml:"connectionPointOut"`
}

// BodyLDLeftPowerRail BodyLDLeftPowerRail represents the inline complex type
// for element leftPowerRail
type BodyLDLeftPowerRail struct {
	XMLName xml.Name `xml:"leftPowerRail"`
	Position Position `xml:"position"`
	ConnectionPointOut []BodyLDLeftPowerRailConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodyLDRightPowerRail BodyLDRightPowerRail represents the inline complex type
// for element rightPowerRail
type BodyLDRightPowerRail struct {
	XMLName xml.Name `xml:"rightPowerRail"`
	Position Position `xml:"position"`
	ConnectionPointIn []ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodyLDCoil BodyLDCoil represents the inline complex type for element coil
type BodyLDCoil struct {
	XMLName xml.Name `xml:"coil"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	// The operand is a valid boolean iec variable e.g. avar[0]
	Variable string `xml:"variable"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
}

// BodyLDContact BodyLDContact represents the inline complex type for element
// contact
type BodyLDContact struct {
	XMLName xml.Name `xml:"contact"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	// The operand is a valid boolean iec variable e.g. avar[0]
	Variable string `xml:"variable"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
}

// BodyLD BodyLD represents the inline complex type for element LD
type BodyLD struct {
	XMLName xml.Name `xml:"LD"`
	Comment *BodyLDComment `xml:"comment,omitempty"`
	Error *BodyLDError `xml:"error,omitempty"`
	Connector *BodyLDConnector `xml:"connector,omitempty"`
	// Counterpart of the connector element
	Continuation *BodyLDContinuation `xml:"continuation,omitempty"`
	ActionBlock *BodyLDActionBlock `xml:"actionBlock,omitempty"`
	Block *BodyLDBlock `xml:"block,omitempty"`
	// Expression used as producer
	InVariable *BodyLDInVariable `xml:"inVariable,omitempty"`
	// Expression used as consumer
	OutVariable *BodyLDOutVariable `xml:"outVariable,omitempty"`
	// Expression used as producer and consumer
	InOutVariable *BodyLDInOutVariable `xml:"inOutVariable,omitempty"`
	Label *BodyLDLabel `xml:"label,omitempty"`
	Jump *BodyLDJump `xml:"jump,omitempty"`
	Return *BodyLDReturn `xml:"return,omitempty"`
	LeftPowerRail *BodyLDLeftPowerRail `xml:"leftPowerRail,omitempty"`
	RightPowerRail *BodyLDRightPowerRail `xml:"rightPowerRail,omitempty"`
	Coil *BodyLDCoil `xml:"coil,omitempty"`
	Contact *BodyLDContact `xml:"contact,omitempty"`
}

// BodySFCComment BodySFCComment represents the inline complex type for element
// comment
type BodySFCComment struct {
	XMLName xml.Name `xml:"comment"`
	Position Position `xml:"position"`
	Content FormattedText `xml:"content"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height float64 `xml:"height,attr"`
	Width float64 `xml:"width,attr"`
}

// BodySFCError BodySFCError represents the inline complex type for element
// error
type BodySFCError struct {
	XMLName xml.Name `xml:"error"`
	Position Position `xml:"position"`
	Content FormattedText `xml:"content"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height float64 `xml:"height,attr"`
	Width float64 `xml:"width,attr"`
}

// BodySFCConnector BodySFCConnector represents the inline complex type for
// element connector
type BodySFCConnector struct {
	XMLName xml.Name `xml:"connector"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	// The operand is a valid iec variable e.g. avar[0]
	Name string `xml:"name,attr"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodySFCContinuation BodySFCContinuation represents the inline complex type
// for element continuation
type BodySFCContinuation struct {
	XMLName xml.Name `xml:"continuation"`
	Position Position `xml:"position"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	// The operand is a valid iec variable e.g. avar[0]
	Name string `xml:"name,attr"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodySFCActionBlockActionReference BodySFCActionBlockActionReference
// represents the inline complex type for element reference
type BodySFCActionBlockActionReference struct {
	XMLName xml.Name `xml:"reference"`
	Name string `xml:"name,attr"`
}

// BodySFCActionBlockAction BodySFCActionBlockAction represents the inline
// complex type for element action
type BodySFCActionBlockAction struct {
	XMLName xml.Name `xml:"action"`
	// Name of an action or boolean variable.
	Reference *BodySFCActionBlockActionReference `xml:"reference,omitempty"`
	// Inline implementation of an action body.
	Inline *Body `xml:"inline,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	Qualifier *string `xml:"qualifier,attr"`
	Duration *string `xml:"duration,attr"`
	Indicator *string `xml:"indicator,attr"`
}

// BodySFCActionBlock BodySFCActionBlock represents the inline complex type for
// element actionBlock
type BodySFCActionBlock struct {
	XMLName xml.Name `xml:"actionBlock"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Action []BodySFCActionBlockAction `xml:"action,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	Negated *bool `xml:"negated,attr"`
}

// BodySFCBlockInputVariablesVariable BodySFCBlockInputVariablesVariable
// represents the inline complex type for element variable
type BodySFCBlockInputVariablesVariable struct {
	XMLName xml.Name `xml:"variable"`
	ConnectionPointIn ConnectionPointIn `xml:"connectionPointIn"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	FormalParameter string `xml:"formalParameter,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
	Hidden *bool `xml:"hidden,attr"`
}

// BodySFCBlockInputVariables BodySFCBlockInputVariables represents the inline
// complex type for element inputVariables
type BodySFCBlockInputVariables struct {
	XMLName xml.Name `xml:"inputVariables"`
	Variable []BodySFCBlockInputVariablesVariable `xml:"variable,omitempty"`
}

// BodySFCBlockInOutVariablesVariable BodySFCBlockInOutVariablesVariable
// represents the inline complex type for element variable
type BodySFCBlockInOutVariablesVariable struct {
	XMLName xml.Name `xml:"variable"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	FormalParameter string `xml:"formalParameter,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
	Hidden *bool `xml:"hidden,attr"`
}

// BodySFCBlockInOutVariables BodySFCBlockInOutVariables represents the inline
// complex type for element inOutVariables
type BodySFCBlockInOutVariables struct {
	XMLName xml.Name `xml:"inOutVariables"`
	Variable []BodySFCBlockInOutVariablesVariable `xml:"variable,omitempty"`
}

// BodySFCBlockOutputVariablesVariable BodySFCBlockOutputVariablesVariable
// represents the inline complex type for element variable
type BodySFCBlockOutputVariablesVariable struct {
	XMLName xml.Name `xml:"variable"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	FormalParameter string `xml:"formalParameter,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
	Hidden *bool `xml:"hidden,attr"`
}

// BodySFCBlockOutputVariables BodySFCBlockOutputVariables represents the inline
// complex type for element outputVariables
type BodySFCBlockOutputVariables struct {
	XMLName xml.Name `xml:"outputVariables"`
	Variable []BodySFCBlockOutputVariablesVariable `xml:"variable,omitempty"`
}

// BodySFCBlock BodySFCBlock represents the inline complex type for element
// block
type BodySFCBlock struct {
	XMLName xml.Name `xml:"block"`
	// Anchor position of the box. Top left corner excluding the instance name.
	Position Position `xml:"position"`
	// The list of used input variables (consumers)
	InputVariables BodySFCBlockInputVariables `xml:"inputVariables"`
	// The list of used inOut variables
	InOutVariables BodySFCBlockInOutVariables `xml:"inOutVariables"`
	// The list of used output variables (producers)
	OutputVariables BodySFCBlockOutputVariables `xml:"outputVariables"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Width *float64 `xml:"width,attr"`
	Height *float64 `xml:"height,attr"`
	TypeName string `xml:"typeName,attr"`
	InstanceName *string `xml:"instanceName,attr"`
	// Used to identify the order of execution. Also used to identify one special
	// block if there are several blocks with the same name.
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
}

// BodySFCInVariable BodySFCInVariable represents the inline complex type for
// element inVariable
type BodySFCInVariable struct {
	XMLName xml.Name `xml:"inVariable"`
	Position Position `xml:"position"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	// The operand is a valid iec variable e.g. avar[0].
	Expression string `xml:"expression"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
}

// BodySFCOutVariable BodySFCOutVariable represents the inline complex type for
// element outVariable
type BodySFCOutVariable struct {
	XMLName xml.Name `xml:"outVariable"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	// The operand is a valid iec variable e.g. avar[0].
	Expression string `xml:"expression"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
}

// BodySFCInOutVariable BodySFCInOutVariable represents the inline complex type
// for element inOutVariable
type BodySFCInOutVariable struct {
	XMLName xml.Name `xml:"inOutVariable"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	// The operand is a valid iec variable e.g. avar[0].
	Expression string `xml:"expression"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	NegatedIn *bool `xml:"negatedIn,attr"`
	EdgeIn *EdgeModifierType `xml:"edgeIn,attr"`
	StorageIn *StorageModifierType `xml:"storageIn,attr"`
	NegatedOut *bool `xml:"negatedOut,attr"`
	EdgeOut *EdgeModifierType `xml:"edgeOut,attr"`
	StorageOut *StorageModifierType `xml:"storageOut,attr"`
}

// BodySFCLabel BodySFCLabel represents the inline complex type for element
// label
type BodySFCLabel struct {
	XMLName xml.Name `xml:"label"`
	Position Position `xml:"position"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	Label string `xml:"label,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
}

// BodySFCJump BodySFCJump represents the inline complex type for element jump
type BodySFCJump struct {
	XMLName xml.Name `xml:"jump"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	Label string `xml:"label,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
}

// BodySFCReturn BodySFCReturn represents the inline complex type for element
// return
type BodySFCReturn struct {
	XMLName xml.Name `xml:"return"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
}

// BodySFCLeftPowerRailConnectionPointOut BodySFCLeftPowerRailConnectionPointOut
// represents the inline complex type for element connectionPointOut
type BodySFCLeftPowerRailConnectionPointOut struct {
	XMLName xml.Name `xml:"connectionPointOut"`
}

// BodySFCLeftPowerRail BodySFCLeftPowerRail represents the inline complex type
// for element leftPowerRail
type BodySFCLeftPowerRail struct {
	XMLName xml.Name `xml:"leftPowerRail"`
	Position Position `xml:"position"`
	ConnectionPointOut []BodySFCLeftPowerRailConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodySFCRightPowerRail BodySFCRightPowerRail represents the inline complex
// type for element rightPowerRail
type BodySFCRightPowerRail struct {
	XMLName xml.Name `xml:"rightPowerRail"`
	Position Position `xml:"position"`
	ConnectionPointIn []ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodySFCCoil BodySFCCoil represents the inline complex type for element coil
type BodySFCCoil struct {
	XMLName xml.Name `xml:"coil"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	// The operand is a valid boolean iec variable e.g. avar[0]
	Variable string `xml:"variable"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
}

// BodySFCContact BodySFCContact represents the inline complex type for element
// contact
type BodySFCContact struct {
	XMLName xml.Name `xml:"contact"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	// The operand is a valid boolean iec variable e.g. avar[0]
	Variable string `xml:"variable"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	ExecutionOrderId *uint64 `xml:"executionOrderId,attr"`
	Negated *bool `xml:"negated,attr"`
	Edge *EdgeModifierType `xml:"edge,attr"`
	Storage *StorageModifierType `xml:"storage,attr"`
}

// BodySFCStepConnectionPointOut BodySFCStepConnectionPointOut represents the
// inline complex type for element connectionPointOut
type BodySFCStepConnectionPointOut struct {
	XMLName xml.Name `xml:"connectionPointOut"`
}

// BodySFCStepConnectionPointOutAction BodySFCStepConnectionPointOutAction
// represents the inline complex type for element connectionPointOutAction
type BodySFCStepConnectionPointOutAction struct {
	XMLName xml.Name `xml:"connectionPointOutAction"`
}

// BodySFCStep BodySFCStep represents the inline complex type for element step
type BodySFCStep struct {
	XMLName xml.Name `xml:"step"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *BodySFCStepConnectionPointOut `xml:"connectionPointOut,omitempty"`
	ConnectionPointOutAction *BodySFCStepConnectionPointOutAction `xml:"connectionPointOutAction,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	Name string `xml:"name,attr"`
	InitialStep *bool `xml:"initialStep,attr"`
	Negated *bool `xml:"negated,attr"`
}

// BodySFCMacroStep BodySFCMacroStep represents the inline complex type for
// element macroStep
type BodySFCMacroStep struct {
	XMLName xml.Name `xml:"macroStep"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Body *Body `xml:"body,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	Name *string `xml:"name,attr"`
}

// BodySFCJumpStep BodySFCJumpStep represents the inline complex type for
// element jumpStep
type BodySFCJumpStep struct {
	XMLName xml.Name `xml:"jumpStep"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	TargetName string `xml:"targetName,attr"`
}

// BodySFCTransitionConditionReference BodySFCTransitionConditionReference
// represents the inline complex type for element reference
type BodySFCTransitionConditionReference struct {
	XMLName xml.Name `xml:"reference"`
	Name string `xml:"name,attr"`
}

// BodySFCTransitionConditionInline BodySFCTransitionConditionInline represents
// the inline complex type for element inline
type BodySFCTransitionConditionInline struct {
	XMLName xml.Name `xml:"inline"`
}

// BodySFCTransitionCondition BodySFCTransitionCondition represents the inline
// complex type for element condition
type BodySFCTransitionCondition struct {
	XMLName xml.Name `xml:"condition"`
	Reference *BodySFCTransitionConditionReference `xml:"reference,omitempty"`
	Connection []Connection `xml:"connection,omitempty"`
	Inline *BodySFCTransitionConditionInline `xml:"inline,omitempty"`
	Negated *bool `xml:"negated,attr"`
}

// BodySFCTransition BodySFCTransition represents the inline complex type for
// element transition
type BodySFCTransition struct {
	XMLName xml.Name `xml:"transition"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Condition *BodySFCTransitionCondition `xml:"condition,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	// The priority of a transition is evaluated, if the transition is connected to
	// a selectionDivergence element.
	Priority *uint64 `xml:"priority,attr"`
}

// BodySFCSelectionDivergenceConnectionPointOut
// BodySFCSelectionDivergenceConnectionPointOut represents the inline complex
// type for element connectionPointOut
type BodySFCSelectionDivergenceConnectionPointOut struct {
	XMLName xml.Name `xml:"connectionPointOut"`
}

// BodySFCSelectionDivergence BodySFCSelectionDivergence represents the inline
// complex type for element selectionDivergence
type BodySFCSelectionDivergence struct {
	XMLName xml.Name `xml:"selectionDivergence"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut []BodySFCSelectionDivergenceConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodySFCSelectionConvergenceConnectionPointIn
// BodySFCSelectionConvergenceConnectionPointIn represents the inline complex
// type for element connectionPointIn
type BodySFCSelectionConvergenceConnectionPointIn struct {
	XMLName xml.Name `xml:"connectionPointIn"`
}

// BodySFCSelectionConvergence BodySFCSelectionConvergence represents the inline
// complex type for element selectionConvergence
type BodySFCSelectionConvergence struct {
	XMLName xml.Name `xml:"selectionConvergence"`
	Position Position `xml:"position"`
	ConnectionPointIn []BodySFCSelectionConvergenceConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodySFCSimultaneousDivergenceConnectionPointOut
// BodySFCSimultaneousDivergenceConnectionPointOut represents the inline complex
// type for element connectionPointOut
type BodySFCSimultaneousDivergenceConnectionPointOut struct {
	XMLName xml.Name `xml:"connectionPointOut"`
}

// BodySFCSimultaneousDivergence BodySFCSimultaneousDivergence represents the
// inline complex type for element simultaneousDivergence
type BodySFCSimultaneousDivergence struct {
	XMLName xml.Name `xml:"simultaneousDivergence"`
	Position Position `xml:"position"`
	ConnectionPointIn *ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut []BodySFCSimultaneousDivergenceConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
	Name *string `xml:"name,attr"`
}

// BodySFCSimultaneousConvergence BodySFCSimultaneousConvergence represents the
// inline complex type for element simultaneousConvergence
type BodySFCSimultaneousConvergence struct {
	XMLName xml.Name `xml:"simultaneousConvergence"`
	Position Position `xml:"position"`
	ConnectionPointIn []ConnectionPointIn `xml:"connectionPointIn,omitempty"`
	ConnectionPointOut *ConnectionPointOut `xml:"connectionPointOut,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalId uint64 `xml:"localId,attr"`
	Height *float64 `xml:"height,attr"`
	Width *float64 `xml:"width,attr"`
}

// BodySFC BodySFC represents the inline complex type for element SFC
type BodySFC struct {
	XMLName xml.Name `xml:"SFC"`
	Comment *BodySFCComment `xml:"comment,omitempty"`
	Error *BodySFCError `xml:"error,omitempty"`
	Connector *BodySFCConnector `xml:"connector,omitempty"`
	// Counterpart of the connector element
	Continuation *BodySFCContinuation `xml:"continuation,omitempty"`
	ActionBlock *BodySFCActionBlock `xml:"actionBlock,omitempty"`
	Block *BodySFCBlock `xml:"block,omitempty"`
	// Expression used as producer
	InVariable *BodySFCInVariable `xml:"inVariable,omitempty"`
	// Expression used as consumer
	OutVariable *BodySFCOutVariable `xml:"outVariable,omitempty"`
	// Expression used as producer and consumer
	InOutVariable *BodySFCInOutVariable `xml:"inOutVariable,omitempty"`
	Label *BodySFCLabel `xml:"label,omitempty"`
	Jump *BodySFCJump `xml:"jump,omitempty"`
	Return *BodySFCReturn `xml:"return,omitempty"`
	LeftPowerRail *BodySFCLeftPowerRail `xml:"leftPowerRail,omitempty"`
	RightPowerRail *BodySFCRightPowerRail `xml:"rightPowerRail,omitempty"`
	Coil *BodySFCCoil `xml:"coil,omitempty"`
	Contact *BodySFCContact `xml:"contact,omitempty"`
	// A single step in a SFC Sequence. Actions are associated with a step by using
	// an actionBlock element with a connection to the step element
	Step *BodySFCStep `xml:"step,omitempty"`
	MacroStep *BodySFCMacroStep `xml:"macroStep,omitempty"`
	// Jump to a step, macro step or simultaneous divergence. Acts like a step.
	// Predecessor should be a transition.
	JumpStep *BodySFCJumpStep `xml:"jumpStep,omitempty"`
	Transition *BodySFCTransition `xml:"transition,omitempty"`
	SelectionDivergence *BodySFCSelectionDivergence `xml:"selectionDivergence,omitempty"`
	SelectionConvergence *BodySFCSelectionConvergence `xml:"selectionConvergence,omitempty"`
	SimultaneousDivergence *BodySFCSimultaneousDivergence `xml:"simultaneousDivergence,omitempty"`
	SimultaneousConvergence *BodySFCSimultaneousConvergence `xml:"simultaneousConvergence,omitempty"`
}

// Body Implementation part of a POU, action or transistion
type Body struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd body"`
	// Additional userspecific information to the element
	Documentation *FormattedText `xml:"documentation,omitempty"`
	IL *FormattedText `xml:"IL,omitempty"`
	ST *FormattedText `xml:"ST,omitempty"`
	FBD *BodyFBD `xml:"FBD,omitempty"`
	LD *BodyLD `xml:"LD,omitempty"`
	SFC *BodySFC `xml:"SFC,omitempty"`
}

// VarList List of variable declarations that share the same memory attributes
// (CONSTANT, RETAIN, NON_RETAIN, PERSISTENT); extends ppx:varListPlain
type VarList struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd varList"`
	Name *string `xml:"name,attr"`
	Constant *bool `xml:"constant,attr"`
	Retain *bool `xml:"retain,attr"`
	Nonretain *bool `xml:"nonretain,attr"`
	Persistent *bool `xml:"persistent,attr"`
	Nonpersistent *bool `xml:"nonpersistent,attr"`
}

// VarListPlainVariable VarListPlainVariable represents the inline complex type
// for element variable
type VarListPlainVariable struct {
	XMLName xml.Name `xml:"variable"`
	Type DataType `xml:"type"`
	InitialValue *Value `xml:"initialValue,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	Name string `xml:"name,attr"`
	Address *string `xml:"address,attr"`
}

// VarListPlain List of variable declarations without attributes
type VarListPlain struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd varListPlain"`
	Variable []VarListPlainVariable `xml:"variable,omitempty"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
}

// Position Defines a graphical position in X, Y coordinates
type Position struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd position"`
	X float64 `xml:"x,attr"`
	Y float64 `xml:"y,attr"`
}

// Connection Describes a connection between the consumer element (eg. input
// variable of a function block) and the producer element (eg. output variable
// of a function block). It may contain a list of positions that describes the
// path of the connection.
type Connection struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd connection"`
	// All positions of the directed connection path. If any positions are given,
	// the list has to contain the first (input pin of the consumer element) as
	// well as the last (output pin of the producer element).
	Position []Position `xml:"position,omitempty"`
	// Identifies the element the connection starts from.
	RefLocalId uint64 `xml:"refLocalId,attr"`
	// If present: This attribute denotes the name of the VAR_OUTPUT /
	// VAR_IN_OUTparameter of the pou block that is the start of the connection. If
	// not present: If the refLocalId attribute refers to a pou block, the start of
	// the connection is the first output of this block, which is not ENO. If the
	// refLocalId attribute refers to any other element type, the start of the
	// connection is the elements single native output.
	FormalParameter *string `xml:"formalParameter,attr"`
}

// ConnectionPointIn Defines a connection point on the consumer side
type ConnectionPointIn struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd connectionPointIn"`
	// Relative position of the connection pin. Origin is the anchor position of
	// the block.
	RelPosition *Position `xml:"relPosition,omitempty"`
	Connection []Connection `xml:"connection,omitempty"`
	// The operand is a valid iec variable e.g. avar[0] or an iec expression or
	// multiple token text e.g. a + b (*sum*). An iec 61131-3 parser has to be used
	// to extract variable information.
	Expression string `xml:"expression,omitempty"`
}

// ConnectionPointOut Defines a connection point on the producer side
type ConnectionPointOut struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd connectionPointOut"`
	// Relative position of the connection pin. Origin is the anchor position of
	// the block.
	RelPosition *Position `xml:"relPosition,omitempty"`
	// The operand is a valid iec variable e.g. avar[0].
	Expression *string `xml:"expression,omitempty"`
}

// PouInstance Represents a program or function block instance either running
// with or without a task
type PouInstance struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd pouInstance"`
	Documentation *FormattedText `xml:"documentation,omitempty"`
	Name string `xml:"name,attr"`
	Type string `xml:"type,attr"`
}

// FormattedText Formatted text according to parts of XHTML 1.1
type FormattedText struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd formattedText"`
}

// EdgeModifierType Defines the edge detection behaviour of a variable
type EdgeModifierType string

// EdgeModifierType enumeration values
const (
	EdgeModifierTypeNone EdgeModifierType = "none"
	EdgeModifierTypeFalling EdgeModifierType = "falling"
	EdgeModifierTypeRising EdgeModifierType = "rising"
)

// StorageModifierType Defines the storage mode (S/R) behaviour of a variable
type StorageModifierType string

// StorageModifierType enumeration values
const (
	StorageModifierTypeNone StorageModifierType = "none"
	StorageModifierTypeSet StorageModifierType = "set"
	StorageModifierTypeReset StorageModifierType = "reset"
)

// PouType Defines the different types of a POU
type PouType string

// PouType enumeration values
const (
	PouTypeFunction PouType = "function"
	PouTypeFunctionBlock PouType = "functionBlock"
	PouTypeProgram PouType = "program"
)

// ProjectFileHeader ProjectFileHeader represents the inline complex type for
// element fileHeader
type ProjectFileHeader struct {
	XMLName xml.Name `xml:"fileHeader"`
	CompanyName string `xml:"companyName,attr"`
	CompanyURL *string `xml:"companyURL,attr"`
	ProductName string `xml:"productName,attr"`
	ProductVersion string `xml:"productVersion,attr"`
	ProductRelease *string `xml:"productRelease,attr"`
	CreationDateTime time.Time `xml:"creationDateTime,attr"`
	ContentDescription *string `xml:"contentDescription,attr"`
}

// ProjectContentHeaderCoordinateInfoPageSize
// ProjectContentHeaderCoordinateInfoPageSize represents the inline complex type
// for element pageSize
type ProjectContentHeaderCoordinateInfoPageSize struct {
	XMLName xml.Name `xml:"pageSize"`
	X float64 `xml:"x,attr"`
	Y float64 `xml:"y,attr"`
}

// ProjectContentHeaderCoordinateInfoFbdScaling
// ProjectContentHeaderCoordinateInfoFbdScaling represents the inline complex
// type for element scaling
type ProjectContentHeaderCoordinateInfoFbdScaling struct {
	XMLName xml.Name `xml:"scaling"`
	X float64 `xml:"x,attr"`
	Y float64 `xml:"y,attr"`
}

// ProjectContentHeaderCoordinateInfoFbd ProjectContentHeaderCoordinateInfoFbd
// represents the inline complex type for element fbd
type ProjectContentHeaderCoordinateInfoFbd struct {
	XMLName xml.Name `xml:"fbd"`
	Scaling ProjectContentHeaderCoordinateInfoFbdScaling `xml:"scaling"`
}

// ProjectContentHeaderCoordinateInfoLdScaling
// ProjectContentHeaderCoordinateInfoLdScaling represents the inline complex
// type for element scaling
type ProjectContentHeaderCoordinateInfoLdScaling struct {
	XMLName xml.Name `xml:"scaling"`
	X float64 `xml:"x,attr"`
	Y float64 `xml:"y,attr"`
}

// ProjectContentHeaderCoordinateInfoLd ProjectContentHeaderCoordinateInfoLd
// represents the inline complex type for element ld
type ProjectContentHeaderCoordinateInfoLd struct {
	XMLName xml.Name `xml:"ld"`
	Scaling ProjectContentHeaderCoordinateInfoLdScaling `xml:"scaling"`
}

// ProjectContentHeaderCoordinateInfoSfcScaling
// ProjectContentHeaderCoordinateInfoSfcScaling represents the inline complex
// type for element scaling
type ProjectContentHeaderCoordinateInfoSfcScaling struct {
	XMLName xml.Name `xml:"scaling"`
	X float64 `xml:"x,attr"`
	Y float64 `xml:"y,attr"`
}

// ProjectContentHeaderCoordinateInfoSfc ProjectContentHeaderCoordinateInfoSfc
// represents the inline complex type for element sfc
type ProjectContentHeaderCoordinateInfoSfc struct {
	XMLName xml.Name `xml:"sfc"`
	Scaling ProjectContentHeaderCoordinateInfoSfcScaling `xml:"scaling"`
}

// ProjectContentHeaderCoordinateInfo ProjectContentHeaderCoordinateInfo
// represents the inline complex type for element coordinateInfo
type ProjectContentHeaderCoordinateInfo struct {
	XMLName xml.Name `xml:"coordinateInfo"`
	PageSize *ProjectContentHeaderCoordinateInfoPageSize `xml:"pageSize,omitempty"`
	Fbd ProjectContentHeaderCoordinateInfoFbd `xml:"fbd"`
	Ld ProjectContentHeaderCoordinateInfoLd `xml:"ld"`
	Sfc ProjectContentHeaderCoordinateInfoSfc `xml:"sfc"`
}

// ProjectContentHeader ProjectContentHeader represents the inline complex type
// for element contentHeader
type ProjectContentHeader struct {
	XMLName xml.Name `xml:"contentHeader"`
	Comment *string `xml:"Comment,omitempty"`
	CoordinateInfo ProjectContentHeaderCoordinateInfo `xml:"coordinateInfo"`
	Name string `xml:"name,attr"`
	Version *string `xml:"version,attr"`
	ModificationDateTime *time.Time `xml:"modificationDateTime,attr"`
	Organization *string `xml:"organization,attr"`
	Author *string `xml:"author,attr"`
	// Documentation language of the project e.g. "en-US"
	Language *string `xml:"language,attr"`
}

// ProjectTypesDataTypesDataType ProjectTypesDataTypesDataType represents the
// inline complex type for element dataType
type ProjectTypesDataTypesDataType struct {
	XMLName xml.Name `xml:"dataType"`
	BaseType DataType `xml:"baseType"`
	InitialValue *Value `xml:"initialValue,omitempty"`
	// Additional userspecific information to the element
	Documentation *FormattedText `xml:"documentation,omitempty"`
	Name string `xml:"name,attr"`
}

// ProjectTypesDataTypes ProjectTypesDataTypes represents the inline complex
// type for element dataTypes
type ProjectTypesDataTypes struct {
	XMLName xml.Name `xml:"dataTypes"`
	DataType []ProjectTypesDataTypesDataType `xml:"dataType,omitempty"`
}

// ProjectTypesPousPouInterfaceLocalVars ProjectTypesPousPouInterfaceLocalVars
// represents the inline complex type for element localVars
type ProjectTypesPousPouInterfaceLocalVars struct {
	XMLName xml.Name `xml:"localVars"`
}

// ProjectTypesPousPouInterfaceTempVars ProjectTypesPousPouInterfaceTempVars
// represents the inline complex type for element tempVars
type ProjectTypesPousPouInterfaceTempVars struct {
	XMLName xml.Name `xml:"tempVars"`
}

// ProjectTypesPousPouInterfaceInputVars ProjectTypesPousPouInterfaceInputVars
// represents the inline complex type for element inputVars
type ProjectTypesPousPouInterfaceInputVars struct {
	XMLName xml.Name `xml:"inputVars"`
}

// ProjectTypesPousPouInterfaceOutputVars ProjectTypesPousPouInterfaceOutputVars
// represents the inline complex type for element outputVars
type ProjectTypesPousPouInterfaceOutputVars struct {
	XMLName xml.Name `xml:"outputVars"`
}

// ProjectTypesPousPouInterfaceInOutVars ProjectTypesPousPouInterfaceInOutVars
// represents the inline complex type for element inOutVars
type ProjectTypesPousPouInterfaceInOutVars struct {
	XMLName xml.Name `xml:"inOutVars"`
}

// ProjectTypesPousPouInterfaceExternalVars
// ProjectTypesPousPouInterfaceExternalVars represents the inline complex type
// for element externalVars
type ProjectTypesPousPouInterfaceExternalVars struct {
	XMLName xml.Name `xml:"externalVars"`
}

// ProjectTypesPousPouInterfaceGlobalVars ProjectTypesPousPouInterfaceGlobalVars
// represents the inline complex type for element globalVars
type ProjectTypesPousPouInterfaceGlobalVars struct {
	XMLName xml.Name `xml:"globalVars"`
}

// ProjectTypesPousPouInterface ProjectTypesPousPouInterface represents the
// inline complex type for element interface
type ProjectTypesPousPouInterface struct {
	XMLName xml.Name `xml:"interface"`
	ReturnType *DataType `xml:"returnType,omitempty"`
	// Additional userspecific information to the element
	Documentation *FormattedText `xml:"documentation,omitempty"`
	LocalVars *ProjectTypesPousPouInterfaceLocalVars `xml:"localVars,omitempty"`
	TempVars *ProjectTypesPousPouInterfaceTempVars `xml:"tempVars,omitempty"`
	InputVars *ProjectTypesPousPouInterfaceInputVars `xml:"inputVars,omitempty"`
	OutputVars *ProjectTypesPousPouInterfaceOutputVars `xml:"outputVars,omitempty"`
	InOutVars *ProjectTypesPousPouInterfaceInOutVars `xml:"inOutVars,omitempty"`
	ExternalVars *ProjectTypesPousPouInterfaceExternalVars `xml:"externalVars,omitempty"`
	GlobalVars *ProjectTypesPousPouInterfaceGlobalVars `xml:"globalVars,omitempty"`
	AccessVars *VarList `xml:"accessVars,omitempty"`
}

// ProjectTypesPousPouActionsAction ProjectTypesPousPouActionsAction represents
// the inline complex type for element action
type ProjectTypesPousPouActionsAction struct {
	XMLName xml.Name `xml:"action"`
	Body Body `xml:"body"`
	// Additional userspecific information to the element
	Documentation *FormattedText `xml:"documentation,omitempty"`
	Name string `xml:"name,attr"`
}

// ProjectTypesPousPouActions ProjectTypesPousPouActions represents the inline
// complex type for element actions
type ProjectTypesPousPouActions struct {
	XMLName xml.Name `xml:"actions"`
	Action []ProjectTypesPousPouActionsAction `xml:"action,omitempty"`
}

// ProjectTypesPousPouTransitionsTransition
// ProjectTypesPousPouTransitionsTransition represents the inline complex type
// for element transition
type ProjectTypesPousPouTransitionsTransition struct {
	XMLName xml.Name `xml:"transition"`
	Body Body `xml:"body"`
	// Additional userspecific information to the element
	Documentation *FormattedText `xml:"documentation,omitempty"`
	Name string `xml:"name,attr"`
}

// ProjectTypesPousPouTransitions ProjectTypesPousPouTransitions represents the
// inline complex type for element transitions
type ProjectTypesPousPouTransitions struct {
	XMLName xml.Name `xml:"transitions"`
	Transition []ProjectTypesPousPouTransitionsTransition `xml:"transition,omitempty"`
}

// ProjectTypesPousPou ProjectTypesPousPou represents the inline complex type
// for element pou
type ProjectTypesPousPou struct {
	XMLName xml.Name `xml:"pou"`
	Interface *ProjectTypesPousPouInterface `xml:"interface,omitempty"`
	Actions *ProjectTypesPousPouActions `xml:"actions,omitempty"`
	Transitions *ProjectTypesPousPouTransitions `xml:"transitions,omitempty"`
	Body *Body `xml:"body,omitempty"`
	// Additional userspecific information to the element
	Documentation *FormattedText `xml:"documentation,omitempty"`
	Name string `xml:"name,attr"`
	PouType PouType `xml:"pouType,attr"`
}

// ProjectTypesPous ProjectTypesPous represents the inline complex type for
// element pous
type ProjectTypesPous struct {
	XMLName xml.Name `xml:"pous"`
	Pou []ProjectTypesPousPou `xml:"pou,omitempty"`
}

// ProjectTypes ProjectTypes represents the inline complex type for element
// types
type ProjectTypes struct {
	XMLName xml.Name `xml:"types"`
	DataTypes ProjectTypesDataTypes `xml:"dataTypes"`
	Pous ProjectTypesPous `xml:"pous"`
}

// ProjectInstancesConfigurationsConfigurationResourceTask
// ProjectInstancesConfigurationsConfigurationResourceTask represents the inline
// complex type for element task
type ProjectInstancesConfigurationsConfigurationResourceTask struct {
	XMLName xml.Name `xml:"task"`
	PouInstance []PouInstance `xml:"pouInstance,omitempty"`
	// Additional userspecific information to the element
	Documentation *FormattedText `xml:"documentation,omitempty"`
	Name string `xml:"name,attr"`
	Single *string `xml:"single,attr"`
	Interval *string `xml:"interval,attr"`
	Priority string `xml:"priority,attr"`
}

// ProjectInstancesConfigurationsConfigurationResource
// ProjectInstancesConfigurationsConfigurationResource represents the inline
// complex type for element resource
type ProjectInstancesConfigurationsConfigurationResource struct {
	XMLName xml.Name `xml:"resource"`
	Task []ProjectInstancesConfigurationsConfigurationResourceTask `xml:"task,omitempty"`
	GlobalVars []VarList `xml:"globalVars,omitempty"`
	PouInstance []PouInstance `xml:"pouInstance,omitempty"`
	// Additional userspecific information to the element
	Documentation *FormattedText `xml:"documentation,omitempty"`
	Name string `xml:"name,attr"`
}

// ProjectInstancesConfigurationsConfiguration
// ProjectInstancesConfigurationsConfiguration represents the inline complex
// type for element configuration
type ProjectInstancesConfigurationsConfiguration struct {
	XMLName xml.Name `xml:"configuration"`
	Resource []ProjectInstancesConfigurationsConfigurationResource `xml:"resource,omitempty"`
	GlobalVars []VarList `xml:"globalVars,omitempty"`
	// Additional userspecific information to the element
	Documentation *FormattedText `xml:"documentation,omitempty"`
	Name string `xml:"name,attr"`
}

// ProjectInstancesConfigurations ProjectInstancesConfigurations represents the
// inline complex type for element configurations
type ProjectInstancesConfigurations struct {
	XMLName xml.Name `xml:"configurations"`
	Configuration []ProjectInstancesConfigurationsConfiguration `xml:"configuration,omitempty"`
}

// ProjectInstances ProjectInstances represents the inline complex type for
// element instances
type ProjectInstances struct {
	XMLName xml.Name `xml:"instances"`
	Configurations ProjectInstancesConfigurations `xml:"configurations"`
}

// Project represents Project
type Project struct {
	XMLName xml.Name `xml:"http://www.plcopen.org/xml/tc6.xsd Project"`
	FileHeader ProjectFileHeader `xml:"fileHeader"`
	ContentHeader ProjectContentHeader `xml:"contentHeader"`
	Types ProjectTypes `xml:"types"`
	Instances ProjectInstances `xml:"instances"`
}

